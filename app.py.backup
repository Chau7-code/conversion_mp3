from flask import Flask, render_template, request, jsonify, send_file, Response, stream_with_context
import sys
import os
import re
import yt_dlp
from urllib.parse import urlparse
import tempfile
import uuid
import shutil
import subprocess
import requests
import zipfile
from pathlib import Path
import threading
import time
import json
from datetime import datetime, timedelta

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'downloads'
app.config['FFMPEG_FOLDER'] = 'ffmpeg_local'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024 * 1024  # 16GB max

# Créer les dossiers nécessaires
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['FFMPEG_FOLDER'], exist_ok=True)

# Dictionnaire pour stocker les progressions des téléchargements
download_progress = {}

def get_local_ffmpeg_path():
    """Retourne le chemin vers FFmpeg local s'il existe"""
    if os.name == 'nt':  # Windows
        ffmpeg_exe = os.path.join(app.config['FFMPEG_FOLDER'], 'ffmpeg.exe')
        ffprobe_exe = os.path.join(app.config['FFMPEG_FOLDER'], 'ffprobe.exe')
    else:  # Linux/Mac
        ffmpeg_exe = os.path.join(app.config['FFMPEG_FOLDER'], 'ffmpeg')
        ffprobe_exe = os.path.join(app.config['FFMPEG_FOLDER'], 'ffprobe')
    
    if os.path.exists(ffmpeg_exe) and os.path.exists(ffprobe_exe):
        return app.config['FFMPEG_FOLDER']
    return None

def check_ffmpeg():
    """Vérifie si FFmpeg est disponible et retourne le chemin si trouvé"""
    # D'abord vérifier FFmpeg local
    local_ffmpeg = get_local_ffmpeg_path()
    if local_ffmpeg:
        return local_ffmpeg
    
    # Ensuite, essayer de trouver FFmpeg dans le PATH
    ffmpeg_path = shutil.which('ffmpeg')
    if ffmpeg_path:
        return os.path.dirname(ffmpeg_path)
    
    # Vérifier les emplacements communs sur Windows
    if os.name == 'nt':
        common_paths = [
            r'C:\\ffmpeg\\bin',
            r'C:\\Program Files\\ffmpeg\\bin',
            r'C:\\Program Files (x86)\\ffmpeg\\bin',
            os.path.join(os.path.expanduser('~'), 'ffmpeg', 'bin'),
        ]
        for path in common_paths:
            if os.path.exists(os.path.join(path, 'ffmpeg.exe')):
                return path
    
    # Essayer de lancer ffmpeg pour vérifier s'il est dans le PATH
    try:
        subprocess.run(['ffmpeg', '-version'], 
                      capture_output=True, 
                      timeout=5,
                      check=True)
        return None  # FFmpeg est dans le PATH
    except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
        return None

def download_ffmpeg_windows():
    """Télécharge et installe FFmpeg pour Windows automatiquement"""
    ffmpeg_dir = app.config['FFMPEG_FOLDER']
    ffmpeg_exe = os.path.join(ffmpeg_dir, 'ffmpeg.exe')
    ffprobe_exe = os.path.join(ffmpeg_dir, 'ffprobe.exe')
    
    # Si déjà installé, retourner
    if os.path.exists(ffmpeg_exe) and os.path.exists(ffprobe_exe):
        return True
    
    try:
        # URL pour télécharger FFmpeg Windows (version statique)
        # Utilisation d'un CDN fiable pour FFmpeg Windows
        url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
        
        print("Téléchargement de FFmpeg en cours...")
        response = requests.get(url, stream=True, timeout=30)
        response.raise_for_status()
        
        zip_path = os.path.join(ffmpeg_dir, 'ffmpeg.zip')
        total_size = int(response.headers.get('content-length', 0))
        
        with open(zip_path, 'wb') as f:
            downloaded = 0
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
                    downloaded += len(chunk)
                    if total_size > 0:
                        progress = (downloaded / total_size) * 100
                        if int(progress) % 10 == 0:  # Afficher tous les 10%
                            print(f"Téléchargement: {int(progress)}%")
        
        print("Extraction de FFmpeg...")
        # Créer un dossier temporaire pour l'extraction
        temp_extract_dir = os.path.join(ffmpeg_dir, 'temp_extract')
        os.makedirs(temp_extract_dir, exist_ok=True)
        
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            # Extraire tout dans le dossier temporaire
            zip_ref.extractall(temp_extract_dir)
        
        # Chercher ffmpeg.exe et ffprobe.exe dans les sous-dossiers
        for root, dirs, files in os.walk(temp_extract_dir):
            for file in files:
                if file == 'ffmpeg.exe' and not os.path.exists(ffmpeg_exe):
                    source = os.path.join(root, file)
                    shutil.copy2(source, ffmpeg_exe)
        else:
            print("Erreur: FFmpeg non trouvé après extraction")
            return False
            
    except Exception as e:
        print(f"Erreur lors du téléchargement de FFmpeg: {str(e)}")
        return False

def ensure_ffmpeg():
    """S'assure que FFmpeg est disponible, le télécharge si nécessaire (synchrone)"""
    # Vérifier d'abord si FFmpeg existe
    ffmpeg_location = check_ffmpeg()
    if ffmpeg_location is not None:
        # Convertir en chemin absolu
        return os.path.abspath(ffmpeg_location)
    
    # Si on est sur Windows et FFmpeg n'est pas trouvé, le télécharger
    if os.name == 'nt':
        print("FFmpeg non trouvé. Téléchargement automatique en cours...")
        print("Cela peut prendre quelques minutes. Veuillez patienter...")
        if download_ffmpeg_windows():
            local_path = get_local_ffmpeg_path()
            if local_path:
                # Convertir en chemin absolu
                return os.path.abspath(local_path)
            else:
                raise Exception("FFmpeg installé mais introuvable. Veuillez réessayer.")
        else:
            raise Exception("Impossible de télécharger FFmpeg automatiquement. Veuillez l'installer manuellement.")
    
    raise Exception("FFmpeg n'est pas installé. Sur Linux/Mac, installez-le avec: sudo apt-get install ffmpeg ou brew install ffmpeg")

def is_youtube_url(url):
    """Vérifie si l'URL est une URL YouTube"""
    parsed = urlparse(url)
    return 'youtube.com' in parsed.netloc or 'youtu.be' in parsed.netloc

def is_soundcloud_url(url):
    """Vérifie si l'URL est une URL SoundCloud"""
    parsed = urlparse(url)
    return 'soundcloud.com' in parsed.netloc

def is_spotify_url(url):
    """Vérifie si l'URL est une URL Spotify"""
    parsed = urlparse(url)
    return 'spotify.com' in parsed.netloc

def is_playlist(url):
    """Vérifie si l'URL est une playlist"""
    parsed = urlparse(url)
    if 'youtube.com' in parsed.netloc or 'youtu.be' in parsed.netloc:
        return 'list=' in parsed.query
    elif 'soundcloud.com' in parsed.netloc:
        return '/sets/' in parsed.path
    elif 'spotify.com' in parsed.netloc:
        return '/playlist/' in parsed.path or '/album/' in parsed.path
    return False

def sanitize_filename(filename):
    """Nettoie le nom de fichier pour éviter les caractères spéciaux"""
    # Remplacer les caractères invalides
    invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    # Limiter la longueur
    if len(filename) > 200:
        filename = filename[:200]
    return filename.strip()

def cleanup_temp_files(directory, base_path):
    """Supprime les fichiers temporaires (.m4a, .webm, etc.) après conversion"""
    try:
        base_name = os.path.basename(base_path)
        temp_extensions = ['.m4a', '.webm', '.mp4', '.opus', '.ogg', '.flac', '.wav', '.mkv', '.avi']
        
        for file in os.listdir(directory):
            file_path = os.path.join(directory, file)
            # Supprimer les fichiers temporaires qui correspondent au base_path
            if file.startswith(base_name) and any(file.endswith(ext) for ext in temp_extensions):
                try:
                    os.remove(file_path)
                    print(f"Fichier temporaire supprimé: {file}")
                except Exception as e:
                    print(f"Impossible de supprimer {file}: {e}")
    except Exception as e:
        print(f"Erreur lors du nettoyage des fichiers temporaires: {e}")

def cleanup_all_temp_files(directory):
    """Supprime tous les fichiers temporaires dans le dossier (sauf les MP3)"""
    try:
        temp_extensions = ['.m4a', '.webm', '.mp4', '.opus', '.ogg', '.flac', '.wav', '.mkv', '.avi', '.part', '.ytdl']
        
        for file in os.listdir(directory):
            file_path = os.path.join(directory, file)
            # Supprimer les fichiers temporaires (mais garder les MP3)
            if any(file.endswith(ext) for ext in temp_extensions) and os.path.isfile(file_path):
                try:
                    # Vérifier que le fichier n'est pas en cours d'utilisation
                    # En Windows, on peut vérifier si le fichier est verrouillé
                    os.remove(file_path)
                    print(f"Fichier temporaire supprimé: {file}")
                except PermissionError:
                    # Fichier peut-être encore utilisé, on l'ignore
                    pass
                except Exception as e:
                    print(f"Impossible de supprimer {file}: {e}")
    except Exception as e:
        print(f"Erreur lors du nettoyage général des fichiers temporaires: {e}")

def download_youtube(url, output_path, custom_filename=None, progress_id=None):
    """Méthode optimisée pour télécharger depuis YouTube"""
    base_path = output_path.replace('.mp3', '')
    
    # S'assurer que FFmpeg est disponible
    try:
        ffmpeg_location = ensure_ffmpeg()
    except Exception as e:
        raise Exception(f"Erreur FFmpeg: {str(e)}")
    
    # Vérifier que FFmpeg existe vraiment
    if not ffmpeg_location:
        raise Exception("FFmpeg n'est pas disponible. Veuillez l'installer.")
    
    # Vérifier que les exécutables existent
    if os.name == 'nt':
        ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg.exe')
        ffprobe_exe = os.path.join(ffmpeg_location, 'ffprobe.exe')
    else:
        ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg')
        ffprobe_exe = os.path.join(ffmpeg_location, 'ffprobe')
    
    if not (os.path.exists(ffmpeg_exe) and os.path.exists(ffprobe_exe)):
        raise Exception(f"FFmpeg introuvable dans {ffmpeg_location}. Veuillez réinstaller FFmpeg.")
    
    # Hook de progression
    def progress_hook(d):
        if progress_id:
            status = d.get('status', '')
            if status == 'downloading':
                total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                downloaded_bytes = d.get('downloaded_bytes', 0)
                speed = d.get('speed', 0)
                
                if total_bytes > 0:
                    percent = (downloaded_bytes / total_bytes) * 100
                else:
                    percent = 0
                
                # Calculer le temps estimé
                if speed > 0 and total_bytes > 0:
                    remaining_bytes = total_bytes - downloaded_bytes
                    eta_seconds = remaining_bytes / speed
                    # Intervalle de 10 secondes max d'écart (±5 secondes)
                    eta_approx_min = max(0, int(eta_seconds) - 5)
                    eta_approx_max = max(0, int(eta_seconds) + 5)
                else:
                    eta_seconds = 0
                    eta_approx_min = 0
                    eta_approx_max = 0
                
                download_progress[progress_id] = {
                    'percent': min(100, max(0, percent)),
                    'eta_seconds': eta_seconds,
                    'eta_approx_min': eta_approx_min,
                    'eta_approx_max': eta_approx_max,
                    'speed': speed,
                    'downloaded': downloaded_bytes,
                    'total': total_bytes
                }
            elif status == 'finished':
                download_progress[progress_id] = {
                    'percent': 100,
                    'eta_seconds': 0,
                    'eta_approx_min': 0,
                    'eta_approx_max': 0,
                    'status': 'converting'
                }
    
    ydl_opts = {
        # Format optimal pour YouTube (priorité aux formats audio purs)
        'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio/best',
        'outtmpl': base_path + '.%(ext)s',
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '320',  # Qualité maximale MP3 (320 kbps)
        }],
        'quiet': False,
        'no_warnings': False,
        'progress_hooks': [progress_hook],
    }
    
    # Ajouter le chemin FFmpeg (yt-dlp attend le chemin du dossier, pas l'exécutable)
    ydl_opts['ffmpeg_location'] = ffmpeg_location
    print(f"Utilisation de FFmpeg depuis: {ffmpeg_location}")
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Vérifier l'URL d'abord et extraire les infos
            try:
                info = ydl.extract_info(url, download=False)
                if not info:
                    raise Exception("Impossible d'extraire les informations de l'URL YouTube.")
                
                # Extraire le titre
                title = info.get('title', 'video')
                if custom_filename:
                    final_filename = sanitize_filename(custom_filename)
                else:
                    final_filename = sanitize_filename(title)
                
            except yt_dlp.utils.DownloadError as e:
                error_msg = str(e)
                error_msg = re.sub(r'\x1b\[[0-9;]*m', '', error_msg)
                
                if 'ffmpeg' in error_msg.lower() or 'ffprobe' in error_msg.lower():
                    # Essayer de télécharger FFmpeg automatiquement
                    if os.name == 'nt':
                        raise Exception("FFmpeg est en cours de téléchargement automatique. Veuillez réessayer dans quelques instants.")
                    else:
                        raise Exception("FFmpeg n'est pas installé. Sur Linux/Mac, installez-le avec: sudo apt-get install ffmpeg ou brew install ffmpeg")
                elif '404' in error_msg or 'Not Found' in error_msg:
                    raise Exception("La vidéo YouTube n'existe pas ou n'est plus accessible.")
                elif 'Private' in error_msg or 'private' in error_msg:
                    raise Exception("Cette vidéo YouTube est privée. Seules les vidéos publiques peuvent être téléchargées.")
                else:
                    raise Exception(f"Erreur YouTube: {error_msg}")
            
            # Télécharger et convertir
            ydl.download([url])
            
            # Nettoyer les fichiers temporaires (.m4a, .webm, etc.)
            cleanup_temp_files(os.path.dirname(output_path), base_path)
            
            # Trouver le fichier MP3 créé
            if os.path.exists(output_path):
                final_path = output_path
            else:
                # Chercher le fichier MP3 le plus récent avec le même préfixe
                files = [f for f in os.listdir(os.path.dirname(output_path)) 
                        if f.startswith(os.path.basename(base_path)) and f.endswith('.mp3')]
                if files:
                    files_with_time = [(f, os.path.getmtime(os.path.join(os.path.dirname(output_path), f))) 
                                      for f in files]
                    files_with_time.sort(key=lambda x: x[1], reverse=True)
                    final_path = os.path.join(os.path.dirname(output_path), files_with_time[0][0])
                else:
                    raise Exception("Fichier MP3 non créé après conversion")
            
            # Renommer le fichier si nécessaire
            if custom_filename or title:
                new_final_path = os.path.join(os.path.dirname(final_path), f"{final_filename}.mp3")
                if new_final_path != final_path:
                    if os.path.exists(new_final_path):
                        os.remove(new_final_path)
                    os.rename(final_path, new_final_path)
                    final_path = new_final_path
            
            return final_path, final_filename
    except yt_dlp.utils.DownloadError as e:
        error_msg = str(e)
        error_msg = re.sub(r'\x1b\[[0-9;]*m', '', error_msg)
        
        if 'ffmpeg' in error_msg.lower() or 'ffprobe' in error_msg.lower():
            # Essayer de télécharger FFmpeg automatiquement
            if os.name == 'nt':
                raise Exception("FFmpeg est en cours de téléchargement automatique. Veuillez réessayer dans quelques instants.")
            else:
                raise Exception("FFmpeg n'est pas installé. Sur Linux/Mac, installez-le avec: sudo apt-get install ffmpeg ou brew install ffmpeg")
        raise Exception(f"Erreur YouTube: {error_msg}")
    except Exception as e:
        raise Exception(f"Erreur lors du téléchargement YouTube: {str(e)}")

def download_soundcloud(url, output_path, custom_filename=None, progress_id=None):
    """Méthode optimisée pour télécharger depuis SoundCloud"""
    base_path = output_path.replace('.mp3', '')
    
    # S'assurer que FFmpeg est disponible
    try:
        ffmpeg_location = ensure_ffmpeg()
    except Exception as e:
        raise Exception(f"Erreur FFmpeg: {str(e)}")
    
    # Vérifier que FFmpeg existe vraiment
    if not ffmpeg_location:
        raise Exception("FFmpeg n'est pas disponible. Veuillez l'installer.")
    
    # Vérifier que les exécutables existent
    if os.name == 'nt':
        ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg.exe')
        ffprobe_exe = os.path.join(ffmpeg_location, 'ffprobe.exe')
    else:
        ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg')
        ffprobe_exe = os.path.join(ffmpeg_location, 'ffprobe')
    
    if not (os.path.exists(ffmpeg_exe) and os.path.exists(ffprobe_exe)):
        raise Exception(f"FFmpeg introuvable dans {ffmpeg_location}. Veuillez réinstaller FFmpeg.")
    
    # Hook de progression
    def progress_hook(d):
        if progress_id:
            status = d.get('status', '')
            if status == 'downloading':
                total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                downloaded_bytes = d.get('downloaded_bytes', 0)
                speed = d.get('speed', 0)
                
                if total_bytes > 0:
                    percent = (downloaded_bytes / total_bytes) * 100
                else:
                    percent = 0
                
                # Calculer le temps estimé
                if speed > 0 and total_bytes > 0:
                    remaining_bytes = total_bytes - downloaded_bytes
                    eta_seconds = remaining_bytes / speed
                    # Intervalle de 10 secondes max d'écart (±5 secondes)
                    eta_approx_min = max(0, int(eta_seconds) - 5)
                    eta_approx_max = max(0, int(eta_seconds) + 5)
                else:
                    eta_seconds = 0
                    eta_approx_min = 0
                    eta_approx_max = 0
                
                download_progress[progress_id] = {
                    'percent': min(100, max(0, percent)),
                    'eta_seconds': eta_seconds,
                    'eta_approx_min': eta_approx_min,
                    'eta_approx_max': eta_approx_max,
                    'speed': speed,
                    'downloaded': downloaded_bytes,
                    'total': total_bytes
                }
            elif status == 'finished':
                download_progress[progress_id] = {
                    'percent': 100,
                    'eta_seconds': 0,
                    'eta_approx_min': 0,
                    'eta_approx_max': 0,
                    'status': 'converting'
                }
    
    ydl_opts = {
        # Format optimal pour SoundCloud
        'format': 'bestaudio/best',
        'outtmpl': base_path + '.%(ext)s',
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '320',  # Qualité maximale MP3 (320 kbps)
        }],
        # Options spécifiques SoundCloud
        'extractor_args': {
            'soundcloud': {
                'client_id': None,  # yt-dlp gérera automatiquement
            }
        },
        'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'quiet': False,
        'no_warnings': False,
        'progress_hooks': [progress_hook],
    }
    
    # Ajouter le chemin FFmpeg (yt-dlp attend le chemin du dossier, pas l'exécutable)
    ydl_opts['ffmpeg_location'] = ffmpeg_location
    print(f"Utilisation de FFmpeg depuis: {ffmpeg_location}")
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Vérifier l'URL d'abord et extraire les infos
            try:
                info = ydl.extract_info(url, download=False)
                if not info:
                    raise Exception("Impossible d'extraire les informations de l'URL SoundCloud.")
                
                # Extraire le titre
                title = info.get('title', 'sound')
                if custom_filename:
                    final_filename = sanitize_filename(custom_filename)
                else:
                    final_filename = sanitize_filename(title)
                
            except yt_dlp.utils.DownloadError as e:
                error_msg = str(e)
                error_msg = re.sub(r'\x1b\[[0-9;]*m', '', error_msg)
                
                if 'ffmpeg' in error_msg.lower() or 'ffprobe' in error_msg.lower():
                    # Essayer de télécharger FFmpeg automatiquement
                    if os.name == 'nt':
                        raise Exception("FFmpeg est en cours de téléchargement automatique. Veuillez réessayer dans quelques instants.")
                    else:
                        raise Exception("FFmpeg n'est pas installé. Sur Linux/Mac, installez-le avec: sudo apt-get install ffmpeg ou brew install ffmpeg")
                elif '404' in error_msg or 'Not Found' in error_msg:
                    raise Exception("Le lien SoundCloud n'existe pas ou n'est plus accessible. Vérifiez que l'URL est correcte et que le contenu est public.")
                elif 'Private' in error_msg or 'private' in error_msg:
                    raise Exception("Ce contenu SoundCloud est privé. Seuls les contenus publics peuvent être téléchargés.")
                elif 'client_id' in error_msg.lower():
                    raise Exception("Erreur d'authentification SoundCloud. Essayez de mettre à jour yt-dlp: pip install --upgrade yt-dlp")
                else:
                    raise Exception(f"Erreur SoundCloud: {error_msg}. Essayez de mettre à jour yt-dlp: pip install --upgrade yt-dlp")
            
            # Télécharger et convertir
            ydl.download([url])
            
            # Nettoyer les fichiers temporaires (.m4a, .webm, etc.)
            cleanup_temp_files(os.path.dirname(output_path), base_path)
            
            # Trouver le fichier MP3 créé
            if os.path.exists(output_path):
                final_path = output_path
            else:
                # Chercher le fichier MP3 le plus récent avec le même préfixe
                files = [f for f in os.listdir(os.path.dirname(output_path)) 
                        if f.startswith(os.path.basename(base_path)) and f.endswith('.mp3')]
                if files:
                    files_with_time = [(f, os.path.getmtime(os.path.join(os.path.dirname(output_path), f))) 
                                      for f in files]
                    files_with_time.sort(key=lambda x: x[1], reverse=True)
                    final_path = os.path.join(os.path.dirname(output_path), files_with_time[0][0])
                else:
                    raise Exception("Fichier MP3 non créé après conversion")
            
            # Renommer le fichier si nécessaire
            if custom_filename or title:
                new_final_path = os.path.join(os.path.dirname(final_path), f"{final_filename}.mp3")
                if new_final_path != final_path:
                    if os.path.exists(new_final_path):
                        os.remove(new_final_path)
                    os.rename(final_path, new_final_path)
                    final_path = new_final_path
            
            return final_path, final_filename
    except yt_dlp.utils.DownloadError as e:
        error_msg = str(e)
        error_msg = re.sub(r'\x1b\[[0-9;]*m', '', error_msg)
        
        if 'ffmpeg' in error_msg.lower() or 'ffprobe' in error_msg.lower():
            # Essayer de télécharger FFmpeg automatiquement
            if os.name == 'nt':
                raise Exception("FFmpeg est en cours de téléchargement automatique. Veuillez réessayer dans quelques instants.")
            else:
                raise Exception("FFmpeg n'est pas installé. Sur Linux/Mac, installez-le avec: sudo apt-get install ffmpeg ou brew install ffmpeg")
        raise Exception(f"Erreur SoundCloud: {error_msg}")
    except Exception as e:
        raise Exception(f"Erreur lors du téléchargement SoundCloud: {str(e)}")

def download_spotify(url, output_path, custom_filename=None, progress_id=None):
    """
    Téléchargement depuis Spotify :
    - si spotdl est dispo (module python) -> on l'utilise via sys.executable -m spotdl
    - sinon, ou en cas d'erreur -> fallback automatique sur YouTube (recherche par artiste + titre)
    """
    # S'assurer que FFmpeg est dispo
    try:
        ffmpeg_location = ensure_ffmpeg()
    except Exception as e:
        raise Exception(f"Erreur FFmpeg: {str(e)}")
    
    if not ffmpeg_location:
        raise Exception("FFmpeg n'est pas disponible. Veuillez l'installer.")
    
    # Vérifier si spotdl est installé dans l'environnement Python courant
    spotdl_installed = False
    try:
        import spotdl  # noqa: F401
        spotdl_installed = True
    except ImportError:
        spotdl_installed = False

    # Si spotdl n'est PAS installé -> direct fallback YouTube
    if not spotdl_installed:
        print("[Spotify] Module spotdl non trouvé, utilisation du fallback YouTube.")
        return download_spotify_fallback(url, output_path, custom_filename, progress_id)

    # Sinon on tente spotdl
    try:
        if progress_id:
            download_progress[progress_id] = {
                'percent': 10,
                'eta_seconds': 0,
                'eta_approx_min': 0,
                'eta_approx_max': 0,
                'status': 'searching'
            }

        # Préparer le chemin ffmpeg
        if os.name == 'nt':
            ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg.exe')
        else:
            ffmpeg_exe = os.path.join(ffmpeg_location, 'ffmpeg')

        base_path = output_path.replace('.mp3', '')

        # Utilisation de sys.executable -m spotdl pour éviter les problèmes de PATH
        cmd = [
            sys.executable, '-m', 'spotdl',
            url,
            '--output', app.config['UPLOAD_FOLDER'],
            '--format', 'mp3',
            '--bitrate', '320k',
            '--simple-tui',
        ]

        if os.path.exists(ffmpeg_exe):
            cmd.extend(['--ffmpeg', ffmpeg_exe])
            
        print(f"[Spotify] Exécution de la commande: {' '.join(cmd)}")

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=600,
            check=False
        )
        
        if result.returncode != 0:
            print(f"[Spotify] Erreur spotdl (code {result.returncode}):")
            print(f"STDOUT: {result.stdout}")
            print(f"STDERR: {result.stderr}")
            raise Exception(f"Erreur d'exécution spotdl: {result.stderr}")

        # Chercher le mp3 le plus récent dans le dossier
        files = [
            (f, os.path.getmtime(os.path.join(app.config['UPLOAD_FOLDER'], f)))
            for f in os.listdir(app.config['UPLOAD_FOLDER'])
            if f.endswith('.mp3')
        ]

        if not files:
            raise Exception("Fichier téléchargé introuvable après exécution de spotdl.")

        files.sort(key=lambda x: x[1], reverse=True)
        downloaded_file = files[0][0]
        original_path = os.path.join(app.config['UPLOAD_FOLDER'], downloaded_file)

        cleanup_temp_files(app.config['UPLOAD_FOLDER'], base_path)

        if custom_filename:
            final_filename = sanitize_filename(custom_filename)
        else:
            final_filename = sanitize_filename(downloaded_file.replace('.mp3', ''))

        final_path = original_path
        if custom_filename and final_filename != downloaded_file.replace('.mp3', ''):
            final_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{final_filename}.mp3")
            if os.path.exists(final_path):
                os.remove(final_path)
            os.rename(original_path, final_path)
            final_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{final_filename}.mp3")

        return final_path, final_filename

    except Exception as e:
        # Log de l'erreur spotdl puis fallback
        print(f"[Spotify] Erreur avec spotdl: {e}. Utilisation du fallback YouTube.")
        try:
            return download_spotify_fallback(url, output_path, custom_filename, progress_id)
        except Exception as e2:
            raise Exception(
                f"Erreur lors du téléchargement Spotify avec spotdl: {e}\n"
                f"Le fallback YouTube a aussi échoué: {e2}"
            )

def download_spotify_fallback(url, output_path, custom_filename=None, progress_id=None):
    """
    Fallback Spotify -> on récupère les métadonnées de la page Spotify,
    puis on cherche la musique sur YouTube via yt-dlp (ytsearch:...).
    """
    parsed = urlparse(url)
    path_parts = parsed.path.strip('/').split('/')

    if len(path_parts) < 2:
        raise Exception("URL Spotify invalide. Format attendu: https://open.spotify.com/track/ID")

    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '
                          'AppleWebKit/537.36 (KHTML, like Gecko) '
                          'Chrome/120.0.0.0 Safari/537.36'
        }

        resp = requests.get(url, headers=headers, timeout=10)
        if resp.status_code != 200:
            raise Exception(f"Impossible de charger la page Spotify (status {resp.status_code}).")

        html = resp.text

        # Extraire les métadonnées (titre et artiste) depuis la page Spotify.
        title = None
        artist = None

        # 1) Essayer d'extraire le titre et l'artiste depuis la balise <meta property="og:description">.
        meta_desc = re.search(
            r'<meta\s+property="og:description"\s+content="([^\"]+)"',
            html,
            re.IGNORECASE,
        )
        if meta_desc:
            desc = meta_desc.group(1)
            m = re.match(r'([^,]+),\s+[^,]*\s+by\s+([^,]+)', desc)
            if m:
                title = m.group(1).strip()
                artist = m.group(2).strip()

        # 2) Si le titre n'est pas encore trouvé, on tente la balise <meta property="og:title">.
        if not title:
            meta_title = re.search(
                r'<meta\s+property="og:title"\s+content="([^\"]+)"',
                html,
                re.IGNORECASE,
            )
            if meta_title:
                title_raw = meta_title.group(1).strip()
                separators = [' - ', ' – ', ' — ', ' ― ']
                for sep in separators:
                    if sep in title_raw:
                        parts = [p.strip() for p in title_raw.split(sep) if p.strip()]
                        if len(parts) >= 2:
                            artist = parts[0]
                            title = parts[-1]
                            break
                if not title:
                    title = title_raw

        # 3) Si l'artiste n'est toujours pas trouvé, chercher dans la section JSON "artists"
        if not artist:
            artist_match = re.search(
                r'"artists"\s*:\s*\[\s*\{[^\}]*"name"\s*:\s*"([^\"]+)"',
                html,
                re.IGNORECASE,
            )
            if artist_match:
                artist = artist_match.group(1).strip()

        # 4) Fallback: Spotify.Entity (JSON-LD-like)
        if not title or not artist:
             entity_match = re.search(r'Spotify\.Entity\s*=\s*({.*?});', html, re.DOTALL)
             if entity_match:
                 try:
                     data = json.loads(entity_match.group(1))
                     if 'name' in data:
                         title = data['name']
                     if 'artists' in data and len(data['artists']) > 0:
                         artist = data['artists'][0]['name']
                 except:
                     pass

        source_type = data.get('source_type', '').strip().lower()  # 'youtube' ou 'soundcloud'
        # Gérer le cas où filename peut être None
        filename_value = data.get('filename')
        if filename_value is None:
            custom_filename = None
        else:
            custom_filename = str(filename_value).strip() or None
        
        if not url:
            return jsonify({'error': 'URL vide'}), 400
        
        # Déterminer si c'est une playlist
        is_playlist_url = is_playlist(url)
        
        # Déterminer le type de source
        if source_type == 'youtube' or is_youtube_url(url):
            source_type = 'youtube'
            download_func = download_youtube
        elif source_type == 'soundcloud' or is_soundcloud_url(url):
            source_type = 'soundcloud'
            download_func = download_soundcloud
        elif source_type == 'spotify' or is_spotify_url(url):
            source_type = 'spotify'
            download_func = download_spotify
        else:
            return jsonify({'error': 'URL non supportée. Veuillez utiliser une URL YouTube, SoundCloud ou Spotify'}), 400
        
        # Générer un nom de fichier unique temporaire et un progress_id
        file_id = str(uuid.uuid4())
        progress_id = str(uuid.uuid4())
        
        # Initialiser le suivi de progression
        download_progress[progress_id] = {
            'percent': 0,
            'eta_seconds': 0,
            'eta_approx_min': 0,
            'eta_approx_max': 0,
            'status': 'downloading'
        }
        
        # Vérifier que l'URL est valide
        if not url.startswith(('http://', 'https://')):
            return jsonify({'error': 'URL invalide. L\'URL doit commencer par http:// ou https://'}), 400
        
        # Télécharger et convertir avec la méthode appropriée dans un thread
        def download_thread():
            try:
                if is_playlist_url:
                    # Traitement spécifique pour les playlists
                    final_path, final_filename = process_playlist(url, source_type, progress_id)
                    file_ext = '.zip'
                else:
                    # Traitement normal pour les fichiers uniques
                    output_path = os.path.join(app.config['UPLOAD_FOLDER'], f'{file_id}.mp3')
                    final_path, final_filename = download_func(url, output_path, custom_filename, progress_id)
                    file_ext = '.mp3'
                    
                    # Nettoyer tous les fichiers temporaires dans le dossier (seulement pour single track)
                    cleanup_all_temp_files(app.config['UPLOAD_FOLDER'])
                
                # Vérifier que le fichier existe
                if not os.path.exists(final_path):
                    if not is_playlist_url:
                        # Chercher le fichier .mp3 récemment créé dans le dossier
                        files = [(f, os.path.getmtime(os.path.join(app.config['UPLOAD_FOLDER'], f))) 
                                 for f in os.listdir(app.config['UPLOAD_FOLDER']) if f.endswith('.mp3')]
                        if files:
                            # Prendre le fichier le plus récent
                            files.sort(key=lambda x: x[1], reverse=True)
                            final_path = os.path.join(app.config['UPLOAD_FOLDER'], files[0][0])
                            final_filename = files[0][0].replace('.mp3', '')
                        else:
                            raise Exception("Fichier MP3 non trouvé après conversion")
                    else:
                         raise Exception("Fichier ZIP non trouvé après création de la playlist")
                
                # Utiliser le nom du fichier final comme file_id pour le téléchargement
                file_id_final = os.path.basename(final_path).replace(file_ext, '')

                progress_data = {
                    'percent': 100,
                    'eta_seconds': 0,
                    'eta_approx_min': 0,
                    'eta_approx_max': 0,
                    'status': 'completed',
                    'file_id': file_id_final,
                    'filename': final_filename if final_filename.endswith(file_ext) else f'{final_filename}{file_ext}',
                    'message': f'Conversion {source_type} réussie'
                }
                
                download_progress[progress_id] = progress_data
                print(f"✅ Conversion terminée pour {progress_id}: {progress_data}")

            except Exception as e:
                error_msg = str(e) if e else "Erreur inconnue"
                # Nettoyer le message d'erreur
                if not error_msg or error_msg.strip() == "":
                    error_msg = "Erreur inconnue lors de la conversion"
                # Si le message d'erreur commence par une URL, le remplacer
                if error_msg.startswith(('http://', 'https://')):
                    error_msg = "Erreur lors de la conversion. Veuillez réessayer."
                # Nettoyer les codes ANSI et caractères spéciaux
                error_msg = re.sub(r'\x1b\[[0-9;]*m', '', error_msg)
                error_msg = error_msg.strip()
                
                download_progress[progress_id] = {
                    'percent': 0,
                    'status': 'error',
                    'error': error_msg
                }
        
        thread = threading.Thread(target=download_thread)
        thread.daemon = True
        thread.start()
        
        return jsonify({
            'success': True,
            'progress_id': progress_id
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/download/<file_id>')
def download(file_id):
    # Essayer d'abord MP3, puis ZIP
    mp3_path = os.path.join(app.config['UPLOAD_FOLDER'], f'{file_id}.mp3')
    zip_path = os.path.join(app.config['UPLOAD_FOLDER'], f'{file_id}.zip')
    
    if os.path.exists(mp3_path):
        file_path = mp3_path
        mimetype = 'audio/mpeg'
    elif os.path.exists(zip_path):
        file_path = zip_path
        mimetype = 'application/zip'
    else:
        return jsonify({'error': 'Fichier non trouvé'}), 404
    
    # Obtenir la taille du fichier pour estimer le temps de téléchargement
    file_size = os.path.getsize(file_path)
    # Estimer le temps de téléchargement (environ 1 Mo par seconde pour une connexion moyenne)
    # Ajouter 30 secondes de marge de sécurité
    estimated_download_time = max(60, (file_size / (1024 * 1024)) + 30)
    
    # Utiliser le nom du fichier comme nom de téléchargement
    download_name = os.path.basename(file_path)
    
    # Supprimer le fichier après l'envoi dans un thread
    def delete_file_after_download():
        # Attendre que le téléchargement soit terminé (temps estimé + marge)
        time.sleep(int(estimated_download_time))
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                print(f"Fichier supprimé après téléchargement: {file_path}")
        except Exception as e:
            print(f"Erreur lors de la suppression du fichier: {e}")
    
    thread = threading.Thread(target=delete_file_after_download)
    thread.daemon = True
    thread.start()
    
    return send_file(file_path, as_attachment=True, download_name=download_name, mimetype=mimetype)

@app.route('/delete/<file_id>', methods=['POST'])
def delete_file(file_id):
    """Supprime un fichier du serveur"""
    mp3_path = os.path.join(app.config['UPLOAD_FOLDER'], f'{file_id}.mp3')
    zip_path = os.path.join(app.config['UPLOAD_FOLDER'], f'{file_id}.zip')
    
    try:
        deleted = False
        if os.path.exists(mp3_path):
            os.remove(mp3_path)
            deleted = True
        
        if os.path.exists(zip_path):
            os.remove(zip_path)
            deleted = True
            
        if deleted:
            return jsonify({'success': True, 'message': 'Fichier supprimé'})
        else:
            return jsonify({'error': 'Fichier non trouvé'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/check-progress/<progress_id>')
def check_progress(progress_id):
    """Endpoint simple pour vérifier le statut d'une conversion"""
    data = download_progress.get(progress_id)
    if data:
        return jsonify(data)
    else:
        return jsonify({'status': 'not_found'}), 404

@app.route('/progress/<progress_id>')
def progress(progress_id):
    """
    Flux SSE pour suivre la progression d'un téléchargement / conversion.
    """
    def generate():
        last_state = None
        max_wait = 300  # Maximum 5 minutes d'attente (300 * 0.5s)
        wait_count = 0

        while wait_count < max_wait:
            data = download_progress.get(progress_id)

            if not data:
                wait_count += 1
                time.sleep(0.5)
                continue

            # Comparer les états de manière plus fiable
            current_state_key = json.dumps(data, sort_keys=True)
            last_state_key = json.dumps(last_state, sort_keys=True) if last_state else None

            if current_state_key != last_state_key:
                # on envoie les données au client
                yield f"data: {json.dumps(data)}\n\n"
                last_state = data.copy() if isinstance(data, dict) else data

            # si terminé ou erreur, on envoie un dernier message et on sort
            if data.get('status') in ('completed', 'error'):
                # S'assurer que le dernier message est bien envoyé
                yield f"data: {json.dumps(data)}\n\n"
                break

            time.sleep(0.5)
            wait_count += 1

    return Response(stream_with_context(generate()), mimetype='text/event-stream')

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000, use_reloader=False)