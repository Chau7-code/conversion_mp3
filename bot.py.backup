import os
import discord
from discord.ext import commands
from dotenv import load_dotenv
import downloader
import asyncio
import shutil

# Charger les variables d'environnement
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

# Configuration
UPLOAD_FOLDER = 'downloads_bot'
FFMPEG_FOLDER = 'ffmpeg_local'
downloader.setup(UPLOAD_FOLDER, FFMPEG_FOLDER)

# Configuration du bot
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

@bot.event
async def on_ready():
    print(f'{bot.user} est connect√© √† Discord!')

@bot.command(name='convert')
async def convert(ctx, url: str):
    # V√©rifier si l'utilisateur demande de l'aide
    if url in ['-h', '-help', '--help']:
        embed = discord.Embed(
            title="ü§ñ Pr√©sentation du Bot Musique",
            description="Ce bot vous permet de t√©l√©charger et convertir des musiques depuis plusieurs plateformes directement sur Discord.",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="üõ†Ô∏è Fonctionnalit√©s",
            value=(
                "‚Ä¢ **T√©l√©chargement direct** : Convertit les liens en fichiers MP3.\n"
                "‚Ä¢ **Support Playlists** : T√©l√©charge les playlists compl√®tes et les envoie sous forme de fichier ZIP.\n"
                "‚Ä¢ **Organisation** : Envoie automatiquement les fichiers dans le salon `#musique`."
            ),
            inline=False
        )
        
        embed.add_field(
            name="üåç Plateformes Support√©es",
            value=(
                "‚Ä¢ **YouTube** (Vid√©os & Playlists)\n"
                "‚Ä¢ **SoundCloud** (Tracks & Sets)\n"
                "‚Ä¢ **Spotify** (Tracks & Playlists)\n"
                "‚Ä¢ **Instagram** (Reels)"
            ),
            inline=False
        )
        
        embed.add_field(
            name="üìù Utilisation",
            value="`!convert <url>`",
            inline=False
        )
        
        embed.set_footer(text="Profitez de votre musique ! üéµ")
        await ctx.send(embed=embed)
        return

    # V√©rifier si on est dans le bon channel ou rediriger
    target_channel_name = "musique"
    target_channel = discord.utils.get(ctx.guild.channels, name=target_channel_name)
    
    if not target_channel:
        await ctx.send(f"Le salon '{target_channel_name}' n'existe pas. Veuillez le cr√©er.")
        return

    # Message de confirmation
    status_msg = await ctx.send(f"Traitement de l'URL : {url} ...")

    # Dictionnaire de progression (non utilis√© pour l'affichage temps r√©el ici pour simplifier)
    progress_dict = {}
    progress_id = "bot_task"

    try:
        # Ex√©cuter le t√©l√©chargement dans un thread s√©par√© pour ne pas bloquer le bot
        loop = asyncio.get_event_loop()
        
        # D√©terminer la source
        source_type = 'auto'
        if downloader.is_youtube_url(url):
            source_type = 'youtube'
        elif downloader.is_soundcloud_url(url):
            source_type = 'soundcloud'
        elif downloader.is_spotify_url(url):
            source_type = 'spotify'
        elif downloader.is_instagram_url(url):
            source_type = 'instagram'
        else:
            await status_msg.edit(content="URL non support√©e.")
            return

        await status_msg.edit(content=f"T√©l√©chargement en cours ({source_type})...")

        if downloader.is_playlist(url):
            # Playlist
            zip_path, zip_filename = await loop.run_in_executor(
                None, 
                lambda: downloader.process_playlist(url, source_type, progress_id, progress_dict)
            )
            file_path = zip_path
            filename = zip_filename + ".zip"
        else:
            # Fichier unique
            output_path = os.path.join(UPLOAD_FOLDER, f"{progress_id}.mp3")
            
            if source_type == 'youtube':
                final_path, final_filename = await loop.run_in_executor(None, lambda: downloader.download_youtube(url, output_path, None, progress_id, progress_dict))
            elif source_type == 'soundcloud':
                final_path, final_filename = await loop.run_in_executor(None, lambda: downloader.download_soundcloud(url, output_path, None, progress_id, progress_dict))
            elif source_type == 'spotify':
                final_path, final_filename = await loop.run_in_executor(None, lambda: downloader.download_spotify(url, output_path, None, progress_id, progress_dict))
            elif source_type == 'instagram':
                final_path, final_filename = await loop.run_in_executor(None, lambda: downloader.download_instagram(url, output_path, None, progress_id, progress_dict))
            
            file_path = final_path
            filename = final_filename + ".mp3"

        # V√©rifier que le fichier existe
        if not os.path.exists(file_path):
            await status_msg.edit(content=f"Erreur: Le fichier t√©l√©charg√© n'a pas √©t√© trouv√©: {file_path}")
            return
        
        # V√©rifier la taille du fichier (limite Discord ~8MB sans nitro, on met une limite safe √† 25MB pour les serveurs boost√©s ou on pr√©vient)
        try:
            file_size = os.path.getsize(file_path)
        except OSError as e:
            await status_msg.edit(content=f"Erreur lors de la lecture du fichier: {str(e)}")
            if os.path.exists(file_path):
                os.remove(file_path)
            return
        
        limit_bytes = 25 * 1024 * 1024 # 25 MB
        
        if file_size > limit_bytes:
            await status_msg.edit(content=f"Le fichier est trop volumineux ({file_size / (1024*1024):.2f} MB) pour √™tre envoy√© sur Discord.")
        else:
            await status_msg.edit(content="Envoi du fichier dans le salon musique...")
            try:
                await target_channel.send(f"Conversion demand√©e par {ctx.author.mention}", file=discord.File(file_path, filename=filename))
                await status_msg.edit(content="Fichier envoy√© avec succ√®s !")
            except Exception as send_error:
                await status_msg.edit(content=f"Erreur lors de l'envoi du fichier: {str(send_error)}")

        # Nettoyage
        if os.path.exists(file_path):
            os.remove(file_path)

    except Exception as e:
        await status_msg.edit(content=f"Erreur lors de la conversion : {str(e)}")
        # Nettoyage en cas d'erreur
        if 'file_path' in locals() and os.path.exists(file_path):
            os.remove(file_path)

@bot.command(name='find')
async def find_music(ctx, url: str = None, *args):
    """Identifie une musique depuis une URL en utilisant Shazam"""
    
    # V√©rifier si l'utilisateur demande de l'aide
    if url in ['-h', '-help', '--help', None]:
        embed = discord.Embed(
            title="üéµ Reconnaissance Musicale",
            description="Identifie une musique depuis une URL en utilisant Shazam et renvoie les liens vers diff√©rentes plateformes.",
            color=discord.Color.purple()
        )
        
        embed.add_field(
            name="üåç Plateformes Support√©es",
            value=(
                "‚Ä¢ **YouTube**\n"
                "‚Ä¢ **SoundCloud**\n"
                "‚Ä¢ **Spotify**\n"
                "‚Ä¢ **Instagram**"
            ),
            inline=False
        )
        
        embed.add_field(
            name="üìù Utilisation",
            value=(
                "`!find <url>` - Analyse aux positions par d√©faut (30s, 60s, 90s)\n"
                "`!find <url> -t <timecodes>` - Analyse aux timecodes sp√©cifi√©s"
            ),
            inline=False
        )
        
        embed.add_field(
            name="‚è±Ô∏è Format des Timecodes",
            value=(
                "‚Ä¢ Secondes: `90`\n"
                "‚Ä¢ MM.SS: `19.30` (19 min 30 sec)\n"
                "‚Ä¢ HH.MM.SS: `1.00.00` (1 heure)\n"
                "‚Ä¢ Heures: `1h`, `1h07`, `2H30`\n"
                "‚Ä¢ Heures + MM.SS: `1h11.30`\n"
                "‚Ä¢ HH:MM:SS: `1:30:45`\n"
                "‚Ä¢ Multiples: `19.30;1.00.00;1h11.30`"
            ),
            inline=False
        )
        
        embed.add_field(
            name="üìå Exemples",
            value=(
                "`!find https://youtube.com/watch?v=...`\n"
                "`!find https://instagram.com/reel/... -t 15`\n"
                "`!find <url> -t 19.30;1.00.00;1h11.30`"
            ),
            inline=False
        )
        
        embed.set_footer(text="Trouvez vos musiques pr√©f√©r√©es ! üé∂")
        await ctx.send(embed=embed)
        return
    
    # Parser les arguments pour extraire les timecodes
    timecodes = None
    if args:
        # Chercher l'option -t ou --time
        for i, arg in enumerate(args):
            if arg in ['-t', '--time'] and i + 1 < len(args):
                timecode_str = args[i + 1]
                try:
                    # Parser les timecodes s√©par√©s par des points-virgules
                    timecode_parts = timecode_str.split(';')
                    timecodes = [downloader.parse_timecode(tc.strip()) for tc in timecode_parts]
                except Exception as e:
                    await ctx.send(f"‚ùå Erreur de format des timecodes: {str(e)}")
                    return
                break
    
    # Message de confirmation
    status_msg = await ctx.send(f"üîç Analyse de l'URL : {url} ...")
    
    try:
        # Ex√©cuter la reconnaissance dans un thread s√©par√©
        loop = asyncio.get_event_loop()
        
        await status_msg.edit(content="‚¨áÔ∏è T√©l√©chargement de l'audio...")
        
        # Appeler la fonction de reconnaissance
        result = await downloader.recognize_music_from_url(url, timecodes)
        
        if not result['found']:
            await status_msg.edit(content=f"‚ùå {result['message']}")
            return
        
        # Cr√©er un embed riche avec les r√©sultats
        embed = discord.Embed(
            title="üéµ Musique Identifi√©e !",
            description=f"**{result['title']}**\npar {result['artist']}",
            color=discord.Color.green()
        )
        
        # Ajouter l'image de couverture si disponible
        if result.get('cover_art'):
            embed.set_thumbnail(url=result['cover_art'])
        
        # Ajouter les liens trouv√©s
        links_text = ""
        if 'links' in result and result['links']:
            if 'youtube' in result['links']:
                links_text += f"üé• [YouTube]({result['links']['youtube']})\n"
            if 'spotify' in result['links']:
                links_text += f"üéß [Spotify]({result['links']['spotify']})\n"
            if 'soundcloud' in result['links']:
                links_text += f"‚òÅÔ∏è [SoundCloud]({result['links']['soundcloud']})\n"
            if result.get('shazam_url'):
                links_text += f"üîµ [Shazam]({result['shazam_url']})\n"
        
        if links_text:
            embed.add_field(
                name="üîó Liens",
                value=links_text,
                inline=False
            )
        else:
            embed.add_field(
                name="üîó Liens",
                value="Aucun lien trouv√©",
                inline=False
            )
        
        # Ajouter le timecode o√π la musique a √©t√© trouv√©e
        embed.add_field(
            name="‚è±Ô∏è Trouv√© √†",
            value=f"{result['timecode']}s",
            inline=True
        )
        
        embed.set_footer(text=f"Demand√© par {ctx.author.name}")
        
        await status_msg.delete()
        await ctx.send(embed=embed)
        
    except Exception as e:
        await status_msg.edit(content=f"‚ùå Erreur lors de la reconnaissance : {str(e)}")

if __name__ == '__main__':
    if not TOKEN:
        print("Erreur: Le token Discord n'est pas d√©fini dans le fichier .env")
    else:
        bot.run(TOKEN)
